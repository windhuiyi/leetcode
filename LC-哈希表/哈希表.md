哈希表
=====

![image_hashtable1](../images/image_hashtable1.png)

![image_hashtable2](../images/image_hashtable2.png)

![image_hashtable3](../images/image_hashtable3.png)

![image_hashtable4](../images/image_hashtable4.png)

![image_hashtable6](../images/image_hashtable5.png)

![image_hashtable6](../images/image_hashtable6.png)

## 哈希表简介

哈希表 是一种使用**哈希函数**组织数据的数据结构，它支持**快速插入**和**搜索**。

- 两种不同类型的哈希表
	- **哈希集合** 是 **集合** 的实现方式之一，用于存储 非重复值。
	- **哈希映射** 是 **映射** 的实现之一，用于存储 (key, value) 键值对。

### 哈希表的原理

- 哈希表（又称散列表）的原理为：借助 **哈希函数**，将键映射到存储桶地址

	- 首先开辟一定长度的，具有连续物理地址的桶数组；
	- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；
	- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。

### 负载因子

- **负载因子** 又叫**装填因子**，是哈希表的一个重要参数，它反映了哈希表的装满程度。

- **实际利用桶的个数** 与 **桶的总数** 的比值，称为**负载因子**。
	- 比较合理的负载因子是 **0.7**，如果数据量是 7，则会创建 10 个桶

## 设计哈希表时的问题

### 哈希函数

#### **确定性**
- 哈希函数的键与桶的对应关系具有确定性。也就是说，对于 key 所映射的桶地址，只由 key 键本身决定，而不由其他因素决定
	
#### **尽量简单**
- 哈希函数不应太过复杂。太过于复杂的哈希函数将导致计算桶地址不能快速完成，从而无法快速定位桶

#### **均匀性**
- 映射结果的分布应具有均匀性。对于特定的桶空间，我们应尽量保证数据经过哈希函数映射之后，能够均匀地分布在桶的整个地址空间中。

### 冲突解决

#### 1.线性试探法

- 线性试探法属于开放定址法的一种，除此之外，开放定址法还包括二次探测法、双重哈希法等。

- 所谓线性试探法，就是当插入键 key 时，如果发现桶单元 bucket[hash(key)] 已经被占用，则向下线性寻找，直到找到可以使用的空桶。具体说来，经过第 i 次试探之后，桶单元应为：
	- bucket[(hash(key)+i) mod M],  i=1,2,3…
	
- 当 查找 某个键时，首先会通过哈希函数计算出桶的地址，然后比较该桶中保存的值是否为该键，如果不是，则继续向下寻找。如果查找到末尾，则会从头开始查找。

- 而 删除 某个键时，为了避免查找过程中出现信息丢失，会将删除位置标记为 deleted，这样当进行线性查找时，遇到 deleted 会继续向下查找而不会中断。

####  2.链地址法

- 解决冲突的另一种办法是将桶内产生冲突的键串联成一个链表。

- 发生冲突时，由于都需要进行线性查找，因此会导致查找的成本增加

#### 3.再哈希法

- 双重哈希法，即发生冲突时，通过使用另一个哈希函数来避免冲突。不难想到，另一个哈希函数在构造时，需要具备一些约束条件才能避免再次冲突。
	- 存在一些问题
		- 与线性试探法相比，双重哈希法会消耗较多的时间。
		- 在双重哈希法中，删除会使问题变复杂，如果逻辑删除数量太多，则应重新构造哈希表。

#### 4.公共溢出区法

- 公共溢出区法就是建立另一个哈希表 dict_overflow 作为公共溢出区，当发成冲突时则将该键保存在该哈希表中。

## 设计哈希表 - 解决方案

  为了解决哈希冲突，我们使用 **二维数组** 来实现哈希集合，数组中的每个元素都可以看作一个桶，而在每个桶中又包含一个一维数组，以便保存产生冲突的键。

### 进一步探索-删除
1. 交换
	- 首先，用存储桶中的最后一个元素交换要移除的元素。然后删除最后一个元素。通过这种方法，我们成功地在 O(1)的时间复杂度中去除了元素。

1. 链表
	- 使用链表而不是数组列表。通过这种方式，我们可以在不修改数组中元素顺序的情况下删除元素。该策略时间复杂度为 O(1）。

## 复杂度分析 - 哈希表

#### 对于哈希表，插入和搜索的平均时间复杂度为 **O(1)**，空间复杂度为 **O(n)**。

#### 本质上是为了达到**时间与空间**的平衡

- 如果桶内使用 链表 或者 数组，则最坏情况下，插入和搜索的时间复杂度为 O(n)；
- 如果桶内使用 高度平衡的二叉树 来保存键，则最坏情况下，插入和搜索的时间复杂度为O(log n)。
- 桶的个数与键呈线性关系，空间复杂度为 O(M)

## 实际应用 - 哈希映射

### 情景 Ⅰ - 构造哈希表

- 学会构造哈希表，将是我们熟练应用哈希表的一个前提。构造哈希表前，我们需要仔细分析题目中相关因素之间的关系，然后为键和值选择合适的数据类型。

### 情景 Ⅱ - 哈希表与滑动窗口

- 滑动窗口就是将数组或字符串中的一个分段，形象地看作一个“窗口”，通过更改“窗口”的左右边界，实现窗口的移动、缩放等操作。
- 双指针

## 实际应用 - 设计键

1. 当字符串 / 数组中每个元素的顺序不重要时，可以使用 排序后的字符串 / 数组 作为键。

1. 如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用偏移量作为键。

1. 在树的题目中，可以直接使用 TreeNode 作为键。但在大多数情况下，可以将 子树的序列化结果 作为键。

1. 在矩阵中，你可能会使用 行索引 或 列索引 作为键。

1. 如果需要将矩阵分块，可以将行索引和列索引进行组合以标识该元素属于哪个 块

1. 有时，在矩阵中，你可能会希望将对角线的元素组合在一起。

